// ShaderBG
// Copyright (c) 2025 Harlen Batagelo
// https://github.com/hbatagelo/shaderbg
// SPDX-License-Identifier: GPL-3.0-or-later

//! ShaderToy-style render pass implementation.
//!
//! A [`RenderPass`] represents one stage of the rendering pipeline.
//! Each pass owns two framebuffers so previous-frame data can be sampled
//! while the next frame is rendered.

use chrono::prelude::*;
use gl::types::*;
use std::{collections::HashMap, path::PathBuf};

use crate::{
    frame_controller::*,
    geometry::{Offset, Size},
    mouse_controller::MouseData,
    preset::*,
    renderer::RenderContext,
    shadertoy::to_glsl_version,
    APP_NAME, GL_VERSION,
};

use super::{framebuffer::*, program::*, shader::*, texture_manager::*};

/// Fullscreen vertex shader used by all render passes.
const VERTEX_SHADER: &str = r#"
layout(location=0) in vec2 position;
layout(location=1) in vec2 texCoord;
#ifdef SHADERBG_CUBEMAP
layout(location=2) in vec3 rayDir;
#endif

out vec2 sbg_FragTexCoord;
#ifdef SHADERBG_CUBEMAP
out vec3 sbg_FragRayDir;
#endif

void main() {
    gl_Position = vec4(position, 0.0, 1.0);
    sbg_FragTexCoord = texCoord;
#ifdef SHADERBG_CUBEMAP
    sbg_FragRayDir = rayDir;
#endif
}
"#;

/// Enables cubemap-specific shader paths.
const CUBEMAP_DEFINITION: &str = "#define SHADERBG_CUBEMAP\n";

/// Global define indicating execution inside ShaderBG runtime.
const SHADERBG_DEFINITION: &str = "#define SHADERBG\n";

/// Injected fragment shader interface shared by all passes.
const FRAGMENT_SHADER_HEADER: &str = r#"
in vec2 sbg_FragTexCoord;
#ifdef SHADERBG_CUBEMAP
in vec3 sbg_FragRayDir;
#endif
out vec4 sbg_FragColor;

const vec4 sbg_AssertColor[] = vec4[](vec4(1, 0, 0, 1), vec4(0, 1, 0, 1), vec4(0, 0, 1, 1), vec4(1, 1, 0, 1));
int sbg_AssertChannel = -1;
void st_assert(bool cond, int channel) {
    if (!cond) {
        sbg_AssertChannel = max(sbg_AssertChannel, clamp(channel, 0, 3));
    }
}
void st_assert(bool cond) {
    st_assert(cond, 0);
}

uniform vec3  iResolution;           // viewport resolution (in pixels)
uniform float iTime;                 // shader playback time (in seconds)
uniform float iGlobalTime;           // same as iTime
uniform float iTimeDelta;            // render time (in seconds)
uniform float iFrameRate;            // shader frame rate
uniform int   iFrame;                // shader playback frame
uniform vec4  iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click
uniform vec4  iDate;                 // (year, month, day, time in seconds)
uniform vec3  iChannelResolution[4]; // channel resolution (in pixels)
uniform float iChannelTime[4];       // TODO: channel playback time (in seconds)
uniform float iSampleRate;           // TODO: sound sample rate (i.e., 44100)

uniform vec2  iResolutionOffset;     // Offset to adjust gl_FragCoord when rendering to multiple monitors
"#;

/// Wrapper main function dispatching to `mainImage` or `mainCubemap`.
const FRAGMENT_SHADER_FOOTER: &str = r#"
void main() {
    vec4 color;
#ifdef SHADERBG_CUBEMAP
    mainCubemap(color, gl_FragCoord.xy, vec3(0), normalize(sbg_FragRayDir));
#else
    mainImage(color, gl_FragCoord.xy + iResolutionOffset);
#endif
    sbg_FragColor = sbg_AssertChannel < 0 ? color : sbg_AssertColor[sbg_AssertChannel];
}
"#;

/// Number of faces in a cubemap texture.
const CUBEMAP_NUM_FACES: usize = 6;

/// Resolution of each cubemap face generated by cubemap passes.
const CUBEMAP_FACE_RESOLUTION: u32 = 1024;

/// Type of rendering performed by the pass.
enum PassType {
    /// Standard fullscreen quad rendering.
    Buffer2D,
    /// Cubemap rendering performed once per face.
    Cubemap,
}

/// Cached uniform locations for ShaderToy-compatible uniforms.
///
/// Locations are queried once during construction.
struct UniformLocations {
    i_resolution: GLint,
    i_time: GLint,
    i_global_time: GLint,
    i_time_delta: GLint,
    i_frame_rate: GLint,
    i_frame: GLint,
    i_mouse: GLint,
    i_date: GLint,
    i_channel_resolution: GLint,
    i_resolution_offset: GLint,
    i_channel: [GLint; 4],
}

/// One ShaderToy rendering stage.
///
/// Two framebuffers are maintained and alternated every frame
/// ("ping-pong") so passes can safely read results from the
/// previous frame while writing the next one.
pub struct RenderPass {
    /// Logical pass name (e.g. "Image", "Buffer A").
    name: String,

    /// Compiled shader program used to execute the pass.
    program: Program,

    /// Double-buffered render targets used for ping-pong rendering.
    framebuffers: [Framebuffer; 2],

    /// Rendering mode of the pass (fullscreen or cubemap).
    pass_type: PassType,

    /// Input channels mapped to `iChannel0..3`.
    inputs: [Option<Input>; 4],

    /// Indicates whether this is the final Image pass.
    /// Only the Image pass applies resolution offsets and MSAA resolve.
    is_image_pass: bool,

    /// Cached uniform locations.
    uniform_locations: UniformLocations,
}

impl RenderPass {
    /// Creates a render pass.
    ///
    /// Shader compilation failures fall back to a default shader while
    /// preserving application execution.
    pub fn new(
        name: &str,
        common_shader: &str,
        pass_shader: &str,
        framebuffer_size: Size,
        inputs: [Option<Input>; 4],
        msaa_samples: u32,
    ) -> Result<Self, ShaderError> {
        let mut is_cubemap_pass = name == "Cube A";
        let mut channel_uniform_declarations = String::default();

        for (i, input_opt) in inputs.iter().enumerate() {
            let _type = input_opt.as_ref().map_or("2D", |input| match input._type {
                InputType::Cubemap => "Cube",
                InputType::Misc if input.name == "Cubemap A" => "Cube",
                InputType::Volume => "3D",
                _ => "2D",
            });
            channel_uniform_declarations += &format!("uniform sampler{_type} iChannel{i};\n");
        }

        let version_directive = || format!("#version {}{}0 core\n", GL_VERSION.0, GL_VERSION.1);

        let vertex_shader_source = version_directive()
            + if is_cubemap_pass {
                CUBEMAP_DEFINITION
            } else {
                ""
            }
            + VERTEX_SHADER;

        let fragment_shader_source = &(version_directive()
            + SHADERBG_DEFINITION
            + if is_cubemap_pass {
                CUBEMAP_DEFINITION
            } else {
                ""
            }
            + FRAGMENT_SHADER_HEADER
            + &channel_uniform_declarations
            + "\n"
            + &to_glsl_version(
                &(SHADERBG_DEFINITION.to_string() + common_shader + "\n" + pass_shader + "\n"),
                GL_VERSION,
                false,
            )?
            + "\n"
            + FRAGMENT_SHADER_FOOTER);

        let vertex_shader = Shader::new(&vertex_shader_source, gl::VERTEX_SHADER)?;

        let default_fragment_shader = || {
            let default_shader_source = version_directive()
                + FRAGMENT_SHADER_HEADER
                + &defaults::default_image_shader()
                + FRAGMENT_SHADER_FOOTER;
            Shader::new(&default_shader_source, gl::FRAGMENT_SHADER)
                .expect("Error compiling default fragment shader")
        };

        let fragment_shader = {
            let result = Shader::new(fragment_shader_source, gl::FRAGMENT_SHADER);
            if let Err(err) = result {
                let mut err_msg = format!("Error compiling '{name}' pass shader: {err}")
                    .trim()
                    .to_string();
                let log_file = log_dir().join(format!("{}.frag", name.to_lowercase()));

                if std::fs::write(&log_file, fragment_shader_source).is_ok() {
                    err_msg += &format!(" - Shader saved to {}", log_file.to_str().unwrap());
                }

                log::error!("{}", err_msg);
                is_cubemap_pass = false;
                default_fragment_shader()
            } else {
                result?
            }
        };

        let program = {
            let result = Program::new(&[vertex_shader, fragment_shader]);
            if let Err(err) = result {
                log::error!("Error linking '{name}' pass program: {err}");
                let vertex_shader = Shader::new(&vertex_shader_source, gl::VERTEX_SHADER)?;
                is_cubemap_pass = false;
                Program::new(&[vertex_shader, default_fragment_shader()])?
            } else {
                result?
            }
        };

        let uniform_locations = UniformLocations {
            i_resolution: program.uniform_location("iResolution")?,
            i_time: program.uniform_location("iTime")?,
            i_global_time: program.uniform_location("iGlobalTime")?,
            i_time_delta: program.uniform_location("iTimeDelta")?,
            i_frame_rate: program.uniform_location("iFrameRate")?,
            i_frame: program.uniform_location("iFrame")?,
            i_mouse: program.uniform_location("iMouse")?,
            i_date: program.uniform_location("iDate")?,
            i_channel_resolution: program.uniform_location("iChannelResolution")?,
            i_resolution_offset: program.uniform_location("iResolutionOffset")?,
            i_channel: [
                program.uniform_location("iChannel0")?,
                program.uniform_location("iChannel1")?,
                program.uniform_location("iChannel2")?,
                program.uniform_location("iChannel3")?,
            ],
        };

        let is_image_pass = name == "Image";

        let (pass_type, size, framebuffer_kind) = if is_cubemap_pass {
            (
                PassType::Cubemap,
                Size::new(CUBEMAP_FACE_RESOLUTION, CUBEMAP_FACE_RESOLUTION),
                FramebufferFormat::Cubemap,
            )
        } else {
            (
                PassType::Buffer2D,
                framebuffer_size,
                if is_image_pass {
                    FramebufferFormat::Tex2D
                } else {
                    FramebufferFormat::Tex2DFloat
                },
            )
        };

        Ok(Self {
            name: name.to_string(),
            program,
            framebuffers: [
                Framebuffer::new(size, msaa_samples, framebuffer_kind),
                Framebuffer::new(size, msaa_samples, framebuffer_kind),
            ],
            pass_type,
            inputs,
            is_image_pass,
            uniform_locations,
        })
    }

    /// Returns the logical name of the pass (e.g. "Image", "Buffer A").
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Returns configured input channels (`iChannel0..3`).
    pub fn inputs(&self) -> &[Option<Input>; 4] {
        &self.inputs
    }

    /// Returns the ping-pong framebuffers backing this pass.
    pub fn framebuffers(&self) -> &[Framebuffer; 2] {
        &self.framebuffers
    }

    /// Executes this render pass.
    ///
    /// Selects the appropriate rendering path depending on pass type
    /// and updates the correct framebuffer for the current frame.
    pub fn render_pass(
        &self,
        ctx: &RenderContext,
        frame_tracker: &mut HashMap<String, u32>,
        scaled_resolution_offset: Offset,
    ) {
        let scaled_resolution_offset = if self.is_image_pass {
            scaled_resolution_offset
        } else {
            Offset::default()
        };

        match self.pass_type {
            PassType::Buffer2D => self.render_2d_pass(ctx, frame_tracker, scaled_resolution_offset),
            PassType::Cubemap => self.render_cubemap_pass(ctx, frame_tracker),
        }
    }

    /// Renders a fullscreen 2D pass.
    ///
    /// The framebuffer index alternates every frame to implement
    /// ping-pong rendering.
    fn render_2d_pass(
        &self,
        ctx: &RenderContext,
        frame_tracker: &mut HashMap<String, u32>,
        scaled_resolution_offset: Offset,
    ) {
        // Use the "next" framebuffer so shaders sample from the previous frame.
        let framebuffer_idx = ((ctx.frame_stats.frame_number + 1) % 2) as usize;
        let framebuffer = &self.framebuffers[framebuffer_idx];
        let framebuffer_size = framebuffer.size();

        self.program.bind();

        self.set_common_uniforms(
            ctx.scaled_resolution,
            ctx.mouse_data,
            ctx.framebuffer_scale,
            ctx.frame_stats,
        );
        self.set_channel_uniforms(ctx.texture_manager, frame_tracker, ctx.frame_stats);

        if self.uniform_locations.i_resolution_offset >= 0 {
            unsafe {
                gl::Uniform2f(
                    self.uniform_locations.i_resolution_offset,
                    scaled_resolution_offset.dx() as GLfloat,
                    scaled_resolution_offset.dy() as GLfloat,
                );
            }
        }

        ctx.vaos[0].bind();

        framebuffer.bind();

        unsafe {
            gl::Viewport(
                0,
                0,
                framebuffer_size.width() as i32,
                framebuffer_size.height() as i32,
            );
            gl::DrawArrays(gl::TRIANGLE_STRIP, 0, 4);
        }

        if self.is_image_pass {
            framebuffer.resolve();
        }
    }

    /// Renders a cubemap pass.
    ///
    /// Each cubemap face is rendered independently using a
    /// dedicated VAO providing the correct ray direction.
    fn render_cubemap_pass(&self, ctx: &RenderContext, frame_tracker: &mut HashMap<String, u32>) {
        const CUBEMAP_FACES: [GLenum; CUBEMAP_NUM_FACES] = [
            gl::TEXTURE_CUBE_MAP_POSITIVE_X,
            gl::TEXTURE_CUBE_MAP_NEGATIVE_X,
            gl::TEXTURE_CUBE_MAP_POSITIVE_Y,
            gl::TEXTURE_CUBE_MAP_NEGATIVE_Y,
            gl::TEXTURE_CUBE_MAP_POSITIVE_Z,
            gl::TEXTURE_CUBE_MAP_NEGATIVE_Z,
        ];

        let resolution = Size::new(CUBEMAP_FACE_RESOLUTION, CUBEMAP_FACE_RESOLUTION);
        let framebuffer_idx = ((ctx.frame_stats.frame_number + 1) % 2) as usize;

        self.program.bind();

        self.set_common_uniforms(resolution, ctx.mouse_data, 1., ctx.frame_stats);
        self.set_channel_uniforms(ctx.texture_manager, frame_tracker, ctx.frame_stats);

        for (face_idx, &face) in CUBEMAP_FACES.iter().enumerate() {
            ctx.vaos[face_idx + 1].bind();
            self.framebuffers[framebuffer_idx].bind_cubemap_face(face);

            unsafe {
                gl::Viewport(0, 0, resolution.width() as i32, resolution.height() as i32);
                gl::DrawArrays(gl::TRIANGLE_STRIP, 0, 4);
            }
        }
    }

    /// Uploads ShaderToy-compatible global uniforms.
    ///
    /// Includes timing, resolution, mouse state, frame counters,
    /// and date information.
    fn set_common_uniforms(
        &self,
        scaled_resolution: Size,
        mouse_data: &MouseData,
        framebuffer_scale: f32,
        frame_stats: &FrameStats,
    ) {
        #[inline]
        fn valid(loc: GLint) -> bool {
            loc >= 0
        }

        let i_resolution_location = self.uniform_locations.i_resolution;
        if valid(i_resolution_location) {
            unsafe {
                gl::Uniform3f(
                    i_resolution_location,
                    scaled_resolution.width() as GLfloat,
                    scaled_resolution.height() as GLfloat,
                    1.,
                );
            }
        }

        let i_time_location = self.uniform_locations.i_time;
        if valid(i_time_location) {
            unsafe { gl::Uniform1f(i_time_location, frame_stats.time.as_secs_f32()) };
        }

        let i_global_time_location = self.uniform_locations.i_global_time;
        if valid(i_global_time_location) {
            unsafe { gl::Uniform1f(i_global_time_location, frame_stats.time.as_secs_f32()) };
        }

        let i_time_delta_location = self.uniform_locations.i_time_delta;
        if valid(i_time_delta_location) {
            unsafe { gl::Uniform1f(i_time_delta_location, frame_stats.time_delta.as_secs_f32()) };
        }

        let i_frame_rate_location = self.uniform_locations.i_frame_rate;
        if valid(i_frame_rate_location) {
            unsafe { gl::Uniform1f(i_frame_rate_location, frame_stats.frame_rate as f32) };
        }

        let i_frame_location = self.uniform_locations.i_frame;
        if valid(i_frame_location) {
            unsafe { gl::Uniform1i(i_frame_location, frame_stats.frame_number as i32 % i32::MAX) };
        }

        let i_mouse_location = self.uniform_locations.i_mouse;
        if valid(i_mouse_location) {
            let data = if mouse_data.as_shadertoy_uniform()[0] >= 0 {
                mouse_data
                    .as_shadertoy_uniform()
                    .map(|v| (v as f32 * framebuffer_scale).round())
            } else {
                [0.; 4]
            };
            unsafe { gl::Uniform4fv(i_mouse_location, 1, data.as_ptr()) };
        }

        let i_date_location = self.uniform_locations.i_date;
        if valid(i_date_location) {
            let now = Local::now();
            let year = now.year() as f32;
            let month = (now.month() - 1) as f32;
            let day = now.day() as f32;

            const NANOS_PER_SEC: u32 = 1_000_000_000;
            let time = now.num_seconds_from_midnight() as f32
                + (now.nanosecond() as f32) / (NANOS_PER_SEC as f32);

            unsafe { gl::Uniform4f(i_date_location, year, month, day, time) };
        }
    }

    /// Binds input channels (`iChannel0..3`) and uploads related uniforms.
    ///
    /// Handles external textures, ping-pong buffer dependencies between passes,
    /// cubemap/volume targets, filtering and wrapping modes, and
    /// channel resolution reporting.
    fn set_channel_uniforms(
        &self,
        texture_manager: &TextureManager,
        frame_tracker: &mut HashMap<String, u32>,
        frame_stats: &FrameStats,
    ) {
        let mut channel_resolutions = Vec::<f32>::default();

        for (idx, input) in self
            .inputs
            .iter()
            .enumerate()
            .filter_map(|(idx, opt)| opt.as_ref().map(|input| (idx, input)))
        {
            let mut texture_name = input.name.clone();

            // Buffer inputs reference outputs from other passes.
            // We select the correct ping-pong buffer so a pass never
            // reads from the framebuffer currently being written.
            if matches!(
                input.name.as_str(),
                "Buffer A" | "Buffer B" | "Buffer C" | "Buffer D" | "Cubemap A"
            ) {
                let mut offset = 0;
                if self.name > input.name {
                    let texture_name_with_suffix =
                        input.name.clone() + &(frame_stats.frame_number % 2).to_string();
                    let previous_frame_number = frame_tracker
                        .insert(texture_name_with_suffix, frame_stats.frame_number)
                        .unwrap_or(u32::MAX);
                    if previous_frame_number != frame_stats.frame_number {
                        offset = 1;
                    }
                };
                texture_name += &((frame_stats.frame_number + offset) % 2).to_string();
            }

            if input._type == InputType::Texture && input.vflip {
                texture_name += "vflip";
            }

            let texture_id = if input._type == InputType::Keyboard {
                texture_manager.keyboard_id()
            } else {
                texture_manager.id(&texture_name)
            };

            if let Some(texture_id) = texture_id {
                let target = if input._type == InputType::Cubemap || input.name == "Cubemap A" {
                    gl::TEXTURE_CUBE_MAP
                } else if input._type == InputType::Volume {
                    gl::TEXTURE_3D
                } else {
                    gl::TEXTURE_2D
                };

                unsafe {
                    gl::ActiveTexture(gl::TEXTURE0 + idx as GLuint);
                    gl::BindTexture(target, texture_id);
                }

                let wrap_mode = if input.wrap == WrapMode::Repeat {
                    gl::REPEAT
                } else {
                    gl::CLAMP_TO_EDGE
                };
                unsafe {
                    gl::TexParameteri(target, gl::TEXTURE_WRAP_S, wrap_mode as i32);
                    gl::TexParameteri(target, gl::TEXTURE_WRAP_T, wrap_mode as i32);
                    if target == gl::TEXTURE_3D {
                        gl::TexParameteri(target, gl::TEXTURE_WRAP_R, wrap_mode as i32);
                    }
                }

                let (min_filter, mag_filter) = match input.filter {
                    FilterMode::Nearest => (gl::NEAREST, gl::NEAREST),
                    FilterMode::Linear => (gl::LINEAR, gl::LINEAR),
                    FilterMode::Mipmap => (gl::LINEAR_MIPMAP_LINEAR, gl::LINEAR),
                };
                unsafe {
                    gl::TexParameteri(target, gl::TEXTURE_MIN_FILTER, min_filter as i32);
                    gl::TexParameteri(target, gl::TEXTURE_MAG_FILTER, mag_filter as i32);
                }

                if input._type == InputType::Misc && input.filter == FilterMode::Mipmap {
                    unsafe { gl::GenerateMipmap(target) };
                }

                let i_channel_location = self.uniform_locations.i_channel[idx];
                if i_channel_location >= 0 {
                    unsafe { gl::Uniform1i(i_channel_location, idx as i32) };
                }

                let (mut width, mut height, mut depth): (i32, i32, i32) = (0, 0, 1);
                if input._type == InputType::Cubemap {
                    let target = gl::TEXTURE_CUBE_MAP_POSITIVE_X;
                    unsafe {
                        gl::GetTexLevelParameteriv(target, 0, gl::TEXTURE_WIDTH, &mut width);
                        gl::GetTexLevelParameteriv(target, 0, gl::TEXTURE_HEIGHT, &mut height);
                    }
                } else if input._type == InputType::Volume {
                    unsafe {
                        gl::GetTexLevelParameteriv(target, 0, gl::TEXTURE_WIDTH, &mut width);
                        gl::GetTexLevelParameteriv(target, 0, gl::TEXTURE_HEIGHT, &mut height);
                        gl::GetTexLevelParameteriv(target, 0, gl::TEXTURE_DEPTH, &mut depth);
                    }
                } else {
                    unsafe {
                        gl::GetTexLevelParameteriv(target, 0, gl::TEXTURE_WIDTH, &mut width);
                        gl::GetTexLevelParameteriv(target, 0, gl::TEXTURE_HEIGHT, &mut height);
                    }
                }

                channel_resolutions.push(width as f32);
                channel_resolutions.push(height as f32);
                channel_resolutions.push(depth as f32);
            }
        }

        let i_channel_resolution_location = self.uniform_locations.i_channel_resolution;
        if i_channel_resolution_location >= 0 {
            unsafe {
                gl::Uniform3fv(
                    i_channel_resolution_location,
                    4,
                    channel_resolutions.as_ptr(),
                )
            };
        }
    }
}

/// Returns directory used to store shader compilation logs.
///
/// Falls back to the current working directory if the cache
/// directory cannot be determined.
fn log_dir() -> PathBuf {
    fn fallback_dir() -> PathBuf {
        std::env::current_dir().expect("Failed to get current working directory")
    }

    let dir = dirs::cache_dir()
        .map(|p| p.join(APP_NAME))
        .unwrap_or_else(|| {
            log::warn!("Could not find $XDG_CACHE_HOME or $HOME/.cache; using current directory.");
            fallback_dir()
        });

    if !dir.exists() {
        if let Err(err) = std::fs::create_dir_all(&dir) {
            log::warn!("Failed to create log directory at {}: {err}", dir.display());
            return fallback_dir();
        }
    }

    dir
}
