id = "4fBfWz"
name = "Twitter truchet"
username = "mrange"
description = """
CC0: Twitter truchet
Saw neat multi-level truchet on twitter: https://x.com/byt3m3chanic/status/1828407895614202169
Thought I should try to recreate it. Adding a little red to it as in the tweet would be nice
but now I am too tired.
"""
resolution_scale = 1.0
time_scale = 0.1
time_offset = "0s"
interval_between_frames = "0s"
screen_bounds_policy = "all_monitors"
monitor_selection = ["*"]
layout_mode = "stretch"
filter_mode = "linear"
crossfade_overlap_ratio = 0.0

[image]
shader = """
// CC0: Twitter truchet
//  Saw neat multi-level truchet on twitter: https://x.com/byt3m3chanic/status/1828407895614202169
//  Thought I should try to recreate it. Adding a little red to it as in the tweet would be nice
//  but now I am too tired.

#define TIME        iTime
#define RESOLUTION  iResolution
#define PI          3.141592654
#define TAU         (2.0*PI)

const float blw = 0.01;
const float wlw = 0.125/2.;
const vec3 bgcol = vec3(0.01);
const vec3 fgcol = vec3(0.03);

// License: Unknown, author: Unknown, found: don't remember
float hash(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
}

vec4 truchet0(vec2 p) {
  float
    d0 = abs(length(p-0.5)-0.5)-wlw*4.
  , d1 = abs(length(p+0.5)-0.5)-wlw*4.
  , d2 = abs(d0)-blw*4.
  , d3 = abs(d1)-blw*4.
  ;
  return vec4(d0,d1, d2,d3);
}

void rot4(inout vec2 p, float h) {
  if (h < 1./4.) {
  } else if (h < 2./4.) {
    p = vec2(p.y, -p.x);
  } else if (h < 3./4.) {
    p *= -1.;
  } else {
    p = vec2(-p.y, p.x);
  }
}

vec4 truchet1(vec2 p) {
  float
    d0 = abs(length(p-0.5)-0.5)
  , d1 = abs(length(p+0.5)-0.5)
  , d2 = d0-wlw*6.
  , d3 = d1-wlw*6.
  , d4 = abs(d0-wlw*4.)-wlw*2.
  , d5 = abs(d1-wlw*4.)-wlw*2.
  ;
  d4 = abs(d4)-blw*2.;
  d5 = abs(d5)-blw*2.;



  return vec4(d2,d3, d4,d5);
}

vec4 truchet2(vec2 p) {
  float
    d0 = abs(length(p-0.5)-0.5)
  , d1 = abs(length(p+0.5)-0.5)
  , d2 = d0-wlw*7.
  , d3 = d1-wlw*7.
  , d4 = abs(d0-wlw*2.)-wlw
  , d5 = abs(d1-wlw*2.)-wlw
  , d6 = abs(d0-wlw*6.)-wlw
  , d7 = abs(d1-wlw*6.)-wlw
  , d8 = min(d4, d6)
  , d9 = min(d5, d7)
  ;
  d8 = abs(d8)-blw;
  d9 = abs(d9)-blw;



  return vec4(d2,d3, d8,d9);
}

vec3 cell0(vec3 col, vec2 p, float aa) {
  vec2 tp = p;

  vec2 tn = floor(tp);
  tp -= tn+0.5;

  float h0 = hash(tn+123.4);
  rot4(tp, h0);

  vec4 dt = truchet0(tp);

  col = mix(col, bgcol, smoothstep(aa, -aa, dt.x));
  col = mix(col, fgcol, smoothstep(aa, -aa, dt.z));

  col = mix(col, bgcol, smoothstep(aa, -aa, dt.y));
  col = mix(col, fgcol, smoothstep(aa, -aa, dt.w));

  return col;
}

vec3 cell1(vec3 col, vec2 p, float aa) {
  vec2 tp = p;

  vec2 tn = floor(tp);
  tp -= tn+0.5;

  float
    h0 = hash(tn+123.45)
  , h1 = fract(8667.0*h0)
  ;

  if (h1 > 2./3.) {
    return cell0(col, 2.*p, 2.*aa);
  } else {
    rot4(tp, h0);
    vec4 dt = truchet1(tp);

    col = mix(col, bgcol, smoothstep(aa, -aa, dt.x));
    col = mix(col, fgcol, smoothstep(aa, -aa, dt.z));

    col = mix(col, bgcol, smoothstep(aa, -aa, dt.y));
    col = mix(col, fgcol, smoothstep(aa, -aa, dt.w));
  }

  return col;
}

vec3 cell2(vec3 col, vec2 p, float aa) {
  vec2 tp = p;

  vec2 tn = floor(tp);
  tp -= tn+0.5;

  float
    h0 = hash(tn+123.456)
  , h1 = fract(8667.0*h0)
  ;

  if (h1 > 1./3.) {
    return cell1(col, 2.*p, 2.*aa);
  } else {
    rot4(tp, h0);

    vec4 dt = truchet2(tp);

    col = mix(col, bgcol, smoothstep(aa, -aa, dt.x));
    col = mix(col, fgcol, smoothstep(aa, -aa, dt.z));

    col = mix(col, bgcol, smoothstep(aa, -aa, dt.y));
    col = mix(col, fgcol, smoothstep(aa, -aa, dt.w));
  }

  return col;
}


vec3 effect(vec2 p) {
  vec3 col = bgcol;
  float aa = sqrt(2.)/RESOLUTION.y;

  float iz = 2.;
  vec2 tp = p;

  const float per = 10.;
  float a = TIME/per+100.;
  tp += (per*0.25)*sin(vec2(sqrt(0.5), 1.)*a);

  tp *= iz;
  float taa = aa*iz;

  col = cell2(col, tp, taa);

  return col;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
  vec2 q = fragCoord/RESOLUTION.xy;
  vec2 p = -1. + 2. * q;
  vec2 pp = p;
  p.x *= RESOLUTION.x/RESOLUTION.y;
  vec3 col = effect(p);
  col = sqrt(col);
  fragColor = vec4(col, 1.0);
}"""
